{"/":{"title":"Welcome to developer-notes","data":{}},"/typescript":{"title":"TypeScript","data":{"todo#Todo":"Work in progress!\nBasic\ninterface\nUnions\nGenerics\nEnums\nType Aliases\nType Assertions\nType Guards\nType Inference\nType Compatibility\nType Widening\nType Narrowing\nType Guards\nType Guards and typeof\nType Guards and instanceof\nType Guards and in\nomit and pick\nkeyof object mapping\nimport React from \"react\"\r\n\r\n///////////////////////////////////////////////////////////////////\r\ninterface Person {\r\n  name: string\r\n  age: number\r\n}\r\n\r\ninterface Table {\r\n  list: Person[]\r\n  amount: number\r\n}\r\n\r\nconst DataExample: Table = {\r\n  amount: 3,\r\n  list: [\r\n    {\r\n      name: \"Magnus\",\r\n      age: 41,\r\n    },\r\n    {\r\n      name: \"Olle\",\r\n      age: 7,\r\n    },\r\n  ],\r\n}\r\n\r\nconsole.log(DataExample.amount)\r\nconsole.log(DataExample.list[1].name)\r\n\r\n///////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////\r\n\r\ninterface Person1 {\r\n  name: string\r\n  age: number\r\n}\r\n\r\ninterface Objects<T> {\r\n  list: T[]\r\n  amount: number\r\n}\r\n\r\n// const a: Paginated<Recipient>\r\n// a.content.bankCode\r\n// a.paginationMetaDat.current\r\n\r\nconst DataExample2: Objects<Person1> = {\r\n  amount: 3,\r\n  list: [\r\n    {\r\n      name: \"Magnus\",\r\n      age: 41,\r\n    },\r\n    {\r\n      name: \"Olle\",\r\n      age: 7,\r\n    },\r\n  ],\r\n}\r\n\r\nconsole.log(DataExample2.amount)\r\nconsole.log(DataExample2.list[0].name)\r\n\r\nconst SCOPE = (data: Person1[]) => {\r\n  console.log(data[0].name)\r\n}\r\n\r\nSCOPE(DataExample2.list)\r\n\r\nconst result = DataExample2.list.map((element) => {\r\n  console.log(element.age + 100)\r\n})\r\nconsole.log(result)\r\n\r\n////////////////////////////////////////////////////\r\n\r\n////////////////////////////////////////////////////\r\n\r\ninterface Item {\r\n  id: number\r\n  size: number\r\n}\r\ninterface Example {\r\n  name: string\r\n  items: {\r\n    [key: string]: Item\r\n  }\r\n}\r\n\r\nvar obj: Example = {\r\n  name: \"test\",\r\n  items: {\r\n    a: {\r\n      id: 1,\r\n      size: 10,\r\n    },\r\n    b: {\r\n      id: 2,\r\n      size: 34,\r\n    },\r\n  },\r\n}\r\n\r\nconsole.log(obj.name)\r\nconsole.log(obj.items.b.size)\r\n\r\n////////////////////////////////////////////////////\r\n\r\nconst Nesting = () => {\r\n  //\r\n\r\n  return <></>\r\n}"}},"/javascript/nullchecks":{"title":"Falsy","data":{"":"Javascript threats all these values as false.\nif (false)\r\nif (null)\r\nif (undefined)\r\nif (0)\r\nif (-0)\r\nif (0n)\r\nif (NaN)\r\nif (\"\")","warning-with-falsy-values#Warning with falsy values!":"Be aware that for example 0 kr might just be 0 kr and not false. \r\nThen a more direct comparison might be useful.\nconst data = {\r\n  product: \"Free candy\",\r\n  price: 0,\r\n}\r\n\r\n// Would not show price 0 kr at all because of falsy!\r\nif (data.price) <Cost>data.price</Cost>\r\n\r\n// Output 0 kr. Note that nullcheck loosely compared also detect undefined.\r\n// Below is the same as !x == null || !x == undefined\r\nif (!data.price == null) <Cost>data.price</Cost>\nJavascript threats all these values as true.\nif (true)\r\nif ({})\r\nif ([])\r\nif (42)\r\nif (\"0\")\r\nif (\"false\")\r\nif (new Date())\r\nif (-42)\r\nif (12n)\r\nif (3.14)\r\nif (-3.14)\r\nif (Infinity)\r\nif (-Infinity)\nCommon pattern to check for empty value before making any operations on a variable like toUppercase().\nif (value) {\r\n  // Run if truthy.\r\n  // Check before making operations that would crash runing values like undefined.\r\n  // Be aware that truthy values like empty arrays and objects are concidered true {} []\r\n}\r\nif (!value) {\r\n  // Run if falsy (for cause gards etc with early exit - one line return\r\n  // Be aware that falsy values \"\", 0 etc is concidered false.\r\n}\nThe null (or undefined) value is not loosely equal to any of the other falsy values except\r\nundefined and null itself.\nif (price == null) console.log(\"Price is either null or undefined (nullish)\")\r\nif (price == undefined) console.log(\"Price is either null or undefined (nullish)\")\nThe value of data is: null\r\n    data == 0 false\r\n    data == on false\r\n    data == data true\r\n    data == undefined true\r\n    data == false false\r\n    data == NaN false\r\n    data == \"\" false\nTry to avoid returning null in favor of:\nreturning a default object instead of null\nthrowing an error instead of returning null\nTernary means threesome and takes three operands. This operator is frequently used as a shortcut\r\nfor the if statement.Compare truthy and falsly values.\n$price ? `${price} kr` : \"Free\"\r\n$active ? \"active-class\" : \"\"\nLogical expressions are evaluated left to right.\nThis compares with truthy and falsely\nprice && <Amount>{price}</Amount>\r\n// The same as:\r\nif (price) bli blo bla\r\n\r\narr.length && doSomething(arr)\r\n// The same as:\r\nif (arr.length) doSomething(arr)\nAnd the or sign checks for falsy\nname || <Form>Please enter your missing name</Form>\r\n// The same as:\r\nif (!name) <Form> ...\r\n\r\nconst name = res.name || \"No name found\"\r\n// The same as:\r\nif (!res.name) name = \"No name found\"\nThe new Nullish coalescing operator (??) works like ||, but it only returns the\r\nsecond expression, when the first one is \"nullish\", i.e. null or undefined.It is thus the better alternative to provide defaults, when values like \"\" or 0\r\nare valid values for the first expression, too.\nprice ?? console.log(\"Price\")<Amount<Form>Please enter your missing name</Form>\r\n  // The same as:\r\n  if (!name) <Form> ...\r\n\r\n  const name = res.name || \"No name found\"\r\n  // The same as:\r\n  if (!res.name) name = \"No name found\"\nThe optional chaining operator (?.) enables you to read the value of a property\r\nlocated deep within a chain of connected objects without having to check that each\r\nreference in the chain is valid.The ?. operator is like the . chaining operator, except that instead of causing an\r\nerror if a reference is <Mark>nullish</Mark> (null or undefined), the expression\r\nshort-circuits with a <Mark>return</Mark> value of undefined. When used with\r\nfunction calls, it <Mark>returns</Mark> undefined if the given function does not exist.\nconst adventurer = {\r\n  name: \"Alice\",\r\n  cat: {\r\n    name: \"Dinah\",\r\n  },\r\n}\r\n\r\nconst dogName = adventurer.dog?.name\r\nconsole.log(dogName)\r\n// expected output: undefined\r\n\r\n// Note: The above is the same as: adventure.dog && adventure.dog.name\r\n\r\nconsole.log(adventurer.someNonExistentMethod?.())\r\n// expected output: undefined\nIf you use callbacks or fetch methods from an object with a destructuring\r\nassignment, you may have non-existent values that you cannot call as functions\r\nunless you have tested their existence. Using ?., you can avoid this extra test:\ncatch (err) {\r\n  if (onError) { // Testing if onError really exists\r\n    onError(err.message);\r\n  }\r\n}\r\n\r\n// Width optional chaining:\r\ncatch (err) {\r\n  onError?.(err.message); // no exception if onError is undefined\r\n}\nThe nullish coalescing operator may be used after optional\r\nchaining in order to build a default value when none was found:\nlet customer = {\r\n  name: \"Carl\",\r\n  details: { age: 82 },\r\n}\r\n\r\nconst customerCity = customer?.city ?? \"Unknown city\"\r\nconsole.log(customerCity) // Unknown city\nA good way to check an array is empty or not is with length.\r\nAs long as an array has any elements it concidered a length - even if the value itself is undefined.Remember that an empty array [] is truthy.\nconst arr = [undefined]\r\nconsole.log(arr.length) // 1 (truthy)\nAn object has no length property. Instead count the key. IE9 and above.\nconst obj = { name: \"Foo\" }\r\n\r\nif (Object.keys(obj).length) console.log(\"I have at least one property\")\nIf we stringify the object and the result is simply an opening and closing bracket, we know the object is empty.\nfunction isEmptyObject(obj) {\r\n  return JSON.stringify(obj) === \"{}\"\r\n}\nUsing Underscore and Lodash\n_.isEmpty(obj)\nMissing arguments are only replaced with default values in the case of <Mark>undefined.</Mark>\nconst validate = (toValidate = \"MJAU\") => {\r\n  // Sets toValidate parameter to MJAU ONLY in the argument is undefined.\r\n  console.log(\"tovalidate: \", toValidate)\r\n}"}}}